# Omnifood-draft

Тут буду записывать привила-заметки-гайды по построению Real-World Websites с проекта omnifood.

### General 

В общем использовать для разметки Grid. Flex - для супер маленьких вещей.





<details> <summary> Classes </summary> 

##

Общие заметки по вопросам как-сколько давать пикселей разным елементам. <strong> Одно из самых главных </strong>- при принятии дизайнерских решений не забивать и смотреть на библиотеку Джонаса, с примерами и гайдами по разным елементам.

Ширина страинцы - как стандарт 1200 1140 px, и для херо можно взять побольше - `max-width: 130rem;`. Ну и конечно же `margin: 0 auto;` для отцентровки. 

h1 в херо - `font-size: 6.2rem;`

По боксам: Все аккуратно складывать в разные коробочки, в hero - одна для фото вторая для текста. Лучше <strong> ВСЕМ </strong> боксам давать классы, и использовать только их, они даже могут совпадать с названием бокса. Исключение - когда у елемента классы, что могут пригодится в похожих елементах ещё, и что бы не портить этот класс можно заюзать псевдо, как для картинок, списков, одиночных елементов(что бы не ебаться с названием, по псевдо всё будет понятно).

Ещё можно создавать универсальны классы для грида, типо `.grid` с дисплей и гепом, и `.grid--2cols` с заготовками на 2-3 колонки. А вот пример хорошего универсального контейнера: 

    .container {
     max-width: 120rem;
     padding: 0 3.2rem;
     margin: 0 auto;
    }

Что бы дать елементу маржин, но не используя его классы что пригодяться в будущем(и где маржин может помешать) можно сделать класс с разными маргинами, и применять где нужно.

    .margin-right-small { 
     margin-right: 1.6rem !important;   
     }


##

</details>


<details> <summary> Responsive-Sites </summary> 

##

Вместо пикселей в основном юзать REM - она зависит от размера дефаулт фонт-сайза. Для удобства можно установить   `font-size: 62.5%;` in HTML Что бы 1 rem = 10 px. 

Для адаптации под все виды экранов использую Media Quries - доп. код при определённом размере экрана. При определениии размера нужно его указывать в `em`а не в `rem`. Так как с ремами в этом контексте может вылезти больше багов. Для создания брейкпоинта нужно определиться с размером в пикселях, перевести в em из расчёта  `1rem = 1em = 16px` и округлить: 


    @media (max-width: 84em) {
      .hero {
      max-width: 120rem;
    }

Дальше - по ситуации. Выкрутить маштаб до 100% и уменьшать, пока что-то не сломаеться или не будет слишком большим. У джонаса это - `1200px`. При 1200: Понизить дефаулт фонт сайз на 1 пиксель - `/* 9px / 16px = 56.25% */`, и на одну ступеньку уменьшить заголовки, gap в гриде


##

</details>


<details> <summary> Закрепления навигации </summary> 

##


Удобнее будет закреплять навигацию с фиксированной высотой.

##

</details>


<details> <summary> По форматированию текста </summary> 

##



Применяемы разметы текста:

<strong>Универсальное:</strong> 1.8rem для обычного текста как универсал. и `line-height: 1.8;`, что увеличит расстояние строк на 8/10 от фонт сайза.

Маленькие заголовки - subheadings можно сделать капсом, но после этого лучше увеличить `letter-spacing: 0.75px;`

##

</details>


<details> <summary> По спейсингу между разделами </summary> 

##


За частую паддинги и отступы от заголовков - 96пх

##

</details>


<details> <summary> По фигурам </summary> 

##

Повторюсь: для создания псевдо елемента в CSS: `.step-img-box::before`, после его редачить. Для отцентровки:

    .step-img-box::before {
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    }

Так же новая тула:`-index: -1;`. Помогает с пермещением елементов поверх остальных. Выше значение-выше приоритет. Можно и в минус идти

##

</details>


<details> <summary> Новые свойства </summary> 

    overflow: hidden; 

- даётся родительскому контейнеру, что бы контент внутри ни выходил за границы родителя. Подойдёт для маскирования углов    картинки в карточках с бордер-радиусом

      border-bottom: 1px solid currentColor;

Новые хотворды цветов - `currentColor` & `transparent`, отображает текущий цвет этого же елемента или прозрачный

    background-image: linear-gradient(to right bottom, #eb984e, #e67e22);

Градиент: указать два цвета, и направление. Можно градусами: `90deg`, а можно кейвордами. `to right bottom` - направляеться у правому нижнему углу, начиная с левого верхнего.

       background-image: linear-gradient(
      to right bottom,
      hsla(28, 80%, 61%, 0.3),
      hsla(28, 80%, 52%, 0.5)
    ),
    url("../img/eating.jpg");
     background-size: cover;
     background-position: center;
      
Подгруз фото не через html, а напрямую в CSS. И можно указывать несколько значений. Тут - первым идёт градиент, и под него фото. В градиенте в цвете выставлена прозрачность, по этому всквозь него будет видно фото. Второе свойство: `cover` - указывает, что нужно заполнить всё доступное место. А последнее - выравнивание фото. Не совсем понял как работает, но если родитель обрезает часть фото - выравниванием можно выбрать, какую часть обрезанной фотки будет отображать.

          <div
            class="cta-img-box"
            role="img"
            aria-label="Woman enjoying food"
          ></div>

Так же, если картинка подкреплена только в css - она не будет отображатся на Screen Reader. Ебу что это, но это проблема. Что бы исправить нужно указать новые свойства: дать роль, а `aria-label` - по сути `alt` но для этой ситуации. После этих манипуляций все проблемы с подкреплением картинки через css будут решены. 

        color: inherit;

Не все елементы унаследуют цвета, шрифты. Особенно формы ввода. Что бы не прописывать для них вручную поможет свойство - `inherit`


    .icon-mobile-nav[name="close-outline"] {
      display: none;
    }


Новая возможность выбирать елемент селектором: если у двух боксов одинаковый класс, но разные другие атрибуты, можно выбрать по ним таким способом. То есть он возьмёт бокс `icon-mobile-nav`с атрибутом `name="close-outline"` в html.


    .step-img-box:nth-child(2) {
    }

Выбрать селектором бокс по счету: для этого нужно взять название бокса, и в `nth-child( )` нужно вписать номер по счету в родительском елементе именно этой коробки.


##

</details>

<details> <summary> По анимациям и дизайнерским решениям </summary> 

##

Для подьёма карточек при наводе можно сделать 

    .meal:hover {
      transform: translateY(-1.2rem);
     box-shadow: 0 3.2rem 6.4rem rgba(0, 0, 0, 0.1);
    }

Приподнимет и увеличит тень для реализма. Так не на псевдо классе нужен `transition: all 0.4s;` для плавности.

<strong>Офигенное решение - в выделяющихся секциях брать текст для текста - очень затемнёный бекграунд. Джонас говорил об этом в уроках по дизайну.</strong>


##

Для отдаления одного обьекта от других по максимуму: Сделать весь бокс влекс, и выставить нужному ребёнку `margin-top: auto;`. Работает и горизонтально и вертикально.

    
##

</details>

<details> <summary> Call To Action </summary> 

##

По формам ввода информации - CTA

Пример: 

        <label for="Full-name">Повне ім'я</label>
        <input
            id="Full-name"
            type="text/email/checkbox/многодругого"
            placeholder="Тарас Шевченко"
            required
        />

Есть много ввидов ввода: просто текста, почты, галочки и тд. Они все легко редачатся. По очереди:

Специальный бокс для подписи формы - `<label>`. Для того что бы по нажатию на него активировалась форма его нужно подключить. Для этого присвоит `id` к самому input, и указать свойство в label - `for="Full-name"`

С помощью `type=""` указываем тип вводимой информации. `placeholder=""` - то что будет отоброжаться в форме как пример. `required` - Указывает вводимое поле как обязательное перед отправкой формы.

Для создания СТА нужно сделать отдельный бокс с указанием адреса отправки информации `<form class="cta-form" action="#">`. Как елемент, отправляющий всю форму выступает елемент <button>. 

Выбор с выпадающего списка - ещё способ ввода информации, пример: 

        <label for="select-where">Де ви про нас дізналися?</label>
        <select id="select-where">
            <option value="empty">Виберіть один варіант:</option>
            <option value="Friends">Друзі та Сім'я</option>
            <option value="Youtube">Youtube Відео</option>
            <option value="podcast">Подкаст</option>
            <option value="Facebook">Реклама Facebook</option>
        </select>

С лабелем - всё так же.

`<select>` - обозначает начало и конец самого списка, а елементы в нём - `<option value="empty">` - варианты выбора. Свойство `value="empty"` обозначает какую информацию возвращать при выборе каждого пункта. По умолчанию первым - всегда `empty`. Если елемент будет обязательным к заполнению - отправка формы с выбраным empty не пройдёт. И Именно он отображается в форме как пример ввода.


По стилизации - полностью елостична. Пример с омнифуда:

    .cta-form input,
    .cta-form select {
      width: 100%;
      padding: 1.2rem;
      font-size: 1.8rem;
      font-family: inherit;
      color: #45260a;
      border: none;
      background-color: #fdf2e9;
      border-radius: 9px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .cta-form input::placeholder {
      color: #aaa;
    }

Из нового - псевдокласс `::placeholder`, в котором редактируеться текст-пример в формах.. Новое - фокус состояние для кнопок и полей ввода. Оно отображает, какой елемент выбран, его ВСЕГДА необходимо обозначать и менять для комфортного использования сайта клавиатурой.

    *:focus {
      outline: none;
      box-shadow: 0 0 0 0.8rem rgba(230, 125, 34, 0.1);
    }
  
    .cta *:focus {
      outline: none;
      box-shadow: 0 0 0 0.6rem rgba(253, 242, 233, 0.5);
      transition: all 0.4s;
    }

Этот псевдо обозначает еффект елемента, на котором сейчас фокус. По умолчанию - уродливая черная обводка. Её можно круто заменить - плавной тенью с цветом бренда. Но важно что бы эту тень было везде видно, по этому для разных секций можно менять её цвет - как и видно в примере.



    
##

</details>

