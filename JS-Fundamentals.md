<!-- 
<details> <summary>  HTML </summary>  </details> 
-->

# JavaScript Fundamentals 
###  Черновик с курса The Complete JavaScript Course 2022: From Zero to Expert! 

<details> <summary>  переменные </summary> 

  Обьявление переменной. Есть несколько операторов для этого: 
  
  `let` -  создание переменной с возможностью изменить в будщем. <strong>Can be mutated. </strong>
  
  `const` - создание переменной без возможности давать новое значение. <strong>Immutable variable.</strong>
  
  `var` - полностью как let
  
  <strong>Как их использовать?</strong> Для чистоты кода: обычно const, и let только когда уверены, что её нужно будет менять. Например: год рождения - конст, возраст - лет. Одно - не меняется, второе - да.
  
`let & const` - с обновления ES6, so they are modern JavaScript. const нельзя давать undefined. `var`- старый вариант обьявление переменных, лучше его избегать.
  
 Пример обьявления переменной
  
    let fistname='Jonas';

  #
</details> 

<details> <summary>  types of data </summary> 
  
Есть два вида значений - обьекты и примитивные, все остальные.
  
Примитивные:
  
<strong>`Number`</strong> -Число с плавающей точкой. 23 = 23.0 в js.

<strong>`String`</strong> - просто текст.


<strong>`Boolean`</strong> - логический вид, принимает True/False

  
`Undefined` - Обьявленная переменная без значения, но позже может получить его.

`Null` - Обьявленная переменная но без значения, и дать значение ей его нельзя.

`Symbo` (ES2015)- Переменная с значением, что нельзя изменить. Подробности будут в конце курса.

`BigInt` (ES2020) - Может хранить огромные целые числа.

Пять значений что будут значить в false, когда мы пытаемся преобразовать их boolean. 

`0, '', undefined, NaN, null` except of `falce` of course

<strong>JavaScript has dynamic typing: </strong>В JS в первых трёх типах нет необходимости обозначать тип данных в переменной, как в других языках. Он определяется сам. <strong>И тип данных хранит Само Значение, а не переменная. То есть бокс хранит значениe, что имеет тип данных</strong> Это значит, что можно без проблем менять тип данных в переменной.

Можно менять типы данных между собой - только первые три. Функции для этого - в отдельной вкладке. <strong>Type Coersion:</strong>Так же js меняет типы данных автоматически: для операторов, использующих цифры, как `* ** / -` преобразует тип в намбер. `console.log('23'-'10'*3);` при компиляции выдаст число, а не ошибку. А оператор `+` наоборот - с намберов делает стринги, что бы скомпилировать код и соеденить разные типы данных: `const jonas = "i'm " + 45 + "and another im " + 23;`. В другом языке нужно было бы писать ` + String(23);`, так как плюсование разных типов данных невозможно - будет ошибка. Но не в джаве. 

Классный пример, нужно угадать ответ: 
  
    let n = "1" + 1;
    n = n - 1;
    console.log(n);

  <details><summary>  answer </summary> 10 </details>
  
 #

</details> 

<details> <summary>  операторы </summary> 
  
So an <strong>operator</strong> basically allows us to transform values or combine multiple values and really do all kinds of work with values. Есть много видов операторов, по порядку:
<details> <summary>  mathematical or arihmetic operators </summary> 
  
`+` `-` `/` `*` - очевидные операторы. `console.log(ageJonas * 2, ageJonas / 10);`

`**` - возвести в степень. `2 ** 3;` = 8

`+=` `-=` `*=` `/=`- операция к текущему значению. Пример: `x *= 10;` равно `x = x * 10;`
  
 `++` `--` - Прибавляет/отнимает к текущему значению 1. Example: `x++;` равно `x=x+1;`
  
 Операторы сравнения

`>` `<` `>=` `<=` - сравнивают значения, и возвращают результат в типе boolean. Example: `console.log(200>100)` return: `true`.

`===` & `==` - приравнивают значения. Но тройной - строгий. Двойной - делает коррекцию типов. То есть двойной оператор покажет одно чилсло в двух видах - string & number равными, вернёт `true`. А строгий - вернёт `falce`, так как он не корректирует типы.

`!==` & `!=` - Такой же прикол как и свехру, только знак неравенства

  <strong>Лучше юзать строгий - так как с коррекцией полон тайн и загадок, и может быть причиной неожиданных багов. Негласное правило для чистоты кода.</strong>

##
  </details> 

<details> <summary>  and, or & not operators </summary> 

<img src="https://i.ibb.co/2PKDrXR/image.png" alt="image" width="65%">

Логика работы их с булеаном на картинке. Пример использования всех трех: 
  
    console.log(driversLicense && goodVision);
    console.log(driversLicense || goodVision);
    console.log(!goodVision);
  
Операторы AND & OR работают не только с булианами, а с всеми типами данных. 

OR вернет первый тип данных TRUE. `console.log(3 || 'Danil');` тут оба значения тру, но до второго он даже не дойдет, а вернет первый. То есть он смотрит все значения, возвращает первый труе, а если их нет просто вернет последнее значение. Потому что оператор дает тру при первом значении тру, и зачем ему смотреть дальше первого тру. Он его и вернет.
  
Практическое применение, дать переменной значение в  зависимости от существования свойства:
  
    restaurant.num = 25;
    const guest1 = restaurant.num ? restaurant.num : 10;
    const guest2 = restaurant.num || 10; //но тут баг: если реальное значение 0, он все равно вернет дефаулт-10

AND работает наоборот. Условия его Тру - что бы все значения были тру. Если все значения тру - вернет последнее, или первый попавшийся фолс. С первым фолсом он сразу вернет фолс, и ему нет смысла смотреть дальше.

Практика, в зависимости от существования метода вызвать его:

    if (restaurant.orderPizza) restaurant.orderPizza('PineApple', 'Tomato');
    restaurant.orderPizza && restaurant.orderPizza('PineApple', 'Tomato'); //если метода нет - на первой части и остановится. Если есть- дойдет и закончит на второй части, его вызова.
  
  ### Assignment operators.

    rest2.numGuests = rest2.numGuests || 10;
    rest1.numGuests ||= 10; //Дает значение свойству если его текущее ззначение фолс
    rest1.numGuests &&= 10; //Дает значение свойству если его текущее ззначение труе
    rest1.numGuests ??= 10; //создает свойство и дает значение  если его не существует

Работае почти точно так же,, как и  полная версия но с исключением для АНД. в случае с ним `rest1.numGuests = rest1.numGuests && 10` в таком виде в случае несуществования свойства создacт его и даст андифинед. Если посмотреть логически так и должно быть. но Ассигмент оператор это убирает. В нем этого не будет.
  
##
  </details> 

<details> <summary> Condition operator </summary> 

Он похож на if else, но не находиться в одном разделе с ним потому чтоэто оператор. То есть он даёт после себя значение. Condition operator - is expression. Синтаксис: 

    условие ? если true : если false;
  
Из нюансов - в него можно поместить только одну строку. Пример использования 

    const drink = age >= 18 ? "wine" : "water";

В зависимости от значения переменной `age` присваивает разные значения переменной `drink`. Как короткий if else. Но что важнее - он возвращает значение: 

    console.log(`I like to drink ${age >= 18 ? "wine" : "water"}`);

Сюда бы запихать if else не вышло - это statement, будет ошибка. А для таких мелких решений идеально подойдёт Condition operator.


 ##
  </details>
  
  У разных операторов есть разный приоритет. Это обьясняет, почему в сравхениях двух примеров перед сравнением он считает эти примеры - у операторов сравнения низкий приоритет. Их список можно глянуть на mdn. Так же у разных операторов разный порядок начала считывания - с левой стороны примера или правой. Мб пригодится в дебагинге.
  
  Другие операторы:

`typeof` - выдаёт тип данных переменной или текста после оператора. ! багует при попытке определить тип значения null.
  
#
</details> 

<details> <summary>  Не большие разделы </summary> 

##
  
<details> <summary>  Template literals </summary> 
  С ES6 новый путь вывода strings вместе с переменными. Как было раньше: 
  
  
    const jonas =
    "i'm " + firstName + ", a " + (now - birthYear) + " years old " + job + "!";

  А вот новый путь

    const jonasNew = `I'm ${firstName}, a ${now - birthYear} years old ${job}!`;
  
  То есть для вставки переменных и кода не нужно использовать операторы. Ахуенно! Так же для пепреноса на другую строку достаточно перенести на другую строку в коде, операторы не нужны
  
 I'm Jonas, a 46 years old teacher!
  
##

  </details> 
  
<details> <summary>  IF ELSE </summary> 
  
  Data structure. Состоит из блоков кода.  И любая переменная, которую мы объявляем внутри одного из этих блоков не будет доступа снаружи блока.
  
    if (оцентиаветься) {
    Если положительное - этот код испольняется
    } else {
    если falce в оценке - этот
    }

  Так же можно писать действие без скобок - если оно не большое, в одну строку с функцией
  
    if (age === 18) console.log("YAY");

  Есть ещё разширенная функция - `else if` - идёт после иф перед елсе. Создаёт дополнительное условие, их может быть неограниченное количество

Так же что бы вывести значение с иф елс - нужно его задекларировать снаружи. Ведь все переменные, что мы создадим внутри блоков - не будут доступны снаружи

  ##
  </details> 

<details> <summary> SWITCH </summary> 

`switch` заменяет иф елсе, если нужно в зависимости от разных значений одной переменной выдадть разный результат. То есть тут только одна переменная проверяется. Вот пример:  

    switch (day) {
     case "monday": // day === 'monday'
       console.log("plan course structure");
        console.log("go to coding meetup");
        break;
     case "tuesday":
       console.log("prepare videos");
        break;
     case "wednesday":
      case "thursday":
       console.log("write code exapmles");
       break;
     case "friday":
      console.log("record videos");
      break;
    case "saturday":
    case "sunday":
       console.log("Enjoy the weekend :D");
       break;
    default:
      console.log("not a valid day");
   }

Тут после кейса указываем значение, и после код который он выполнит. После закрыть этот блок кода - бреак, и в конце `default`- в случаэ если все кейсы получат false. Простая и удобная функция



 ##
  </details> 
  

<details> <summary> Expressions & Statements </summary> 

Есть два вида кода - те что дают значение, и те что нет. Зачем это - в разных местах джс ожидает одно из двух - либо expression, либо statement(declaration). <string>Пример:</strong>

    if(23>10) {
        const str = "23 is bigger";
    }

Где можно считать весь код - statement, а вот `"23 is bigger"` в нём - expression. Так же код завершаюшийся на `;` - точно statement. а `120-338` или `true && false && !false` - expression, он даёт после себя значение. А вот сам if else блок в примере - просто прогоняет комманды последовательно, что-то делает но ничего не возвращает.


 ##
  </details> 
  
#
  </details> 

<details> <summary>  Функции </summary>  

Блоки кода, что можно вызвать. Так же есть заготовленные уже, выполняют какую-либо функцию
  
У функций есть несколько типов. Это - декларирующая. Из разницы - декларирующую можно вызвать ещё до ее обьявления. Фцию выражения - нет.

    function calcAge1(birthYear) {
     return 2022 - birthYear;
    }

Это функция - выражение, Expression. Из разницы - функция без имени, и то что возвращает сразу записывает в переменную

    const calcAge2 = function (birthYear) {
      return 2022 - birthYear;
    };

Arrow function. короткая. Если в одну строку - можно без {} и без return  - они уже вшиты и будут работать автоматом. Разница - тут нет кейворда её вызова, подробнее - позже в курсе.

    const calcAge3 = (birthYear) => 2022 - birthYear;

Так же он не получает свой `this`, и использует кейворд выше по скоупу. И не получает свой обьект с аргументами, как это делают другие функции в `Execution context`.
  
### Другие возможности функций:

#### Давать значение по умолчанию аргументам, что будет применено если их не будет. 

    const createBookiing = function (
      flightNum,
      passangersNum = 1,
      price = 199 * passangersNum
    )

#### Беря обьекты за аргументы - он не копирует их, а использует изначальные. По этому при измене агрумента меняеться и сам обьект вне функции.

#### Функции могут возвращать функции.

    const greetArr = greeting => name => console.log(`${greeting} ${name}`);
    greetArr('Hi')('Jonas'); // Hi Jonas

#### HIGHER-ORDER FUNCTIONS, функции высокого порядка.

// В програмаче есть концепт абстракции.Функция не зависит от других, и выполняет только то что от нее зависит. И достигаеться она вызовом другой функции внутри этой

    const oneWord = function (str) {
     return str.replaceAll(' ', '').toLowerCase();
    };

    // Higher order function
    const transformer = function (str, fn) {
      console.log(`Transformed string: ${fn(str)}`);
      console.log(`Transformed by: ${fn.name}`);
    };

    transformer(' JavaScript is the best', oneWord);

#### Робота с кейвордами

Для кейвордов важно, где его вызывают, так как в зависимости от этого он меняется.  `lufthansa.buyPlane()` в коде отдельно - вызовет метод с кейвордом обьекта, так как тут идет обращение к обьекту. Но в других местах, где ожидаються функции - как евентах, там `lufthansa.buyPlane` вернет сам метод, не в контексте своего обьекта, и This кейворд измениться.

CALL method.
Мгновенно вызвыает функцию, где первый агрумент - обьект, которого береться кейворд this. Остальные - агрументы для функции.

    book.call(eurowings, 23, 'Sarah'); // при вызове первый - обьект с кейвордом, остальное - агрументы.

Apply method. То же самое, но принимает аргументы, кроме первого обьекта, в массиве, и саам их деструктуризирует для функции.

    const flightData = [5412, 'Denis Groshev'];

    book.apply(swiss, flightData);
    book.call(swiss, ...flightData); 
    //Оба вызова делают одну работу.

BIND METHOD. Возвращает новую функцию с кейвордом обьекта, указанного в агрументе.

    const bookEW = book.bind(eurowings);
  
  Так как для кейворда важно, где его вызывают, ведь в зависимости от этого он меняеться, это может вызвать проблемы. Бинд поможет это исправить. Супер полезно для евент хэндлеров, так как у них свой Тхис кейворд - элемент.

    document.querySelector('.buy').addEventListener('click', lufthansa.buyPlane.bind(lufthansa));

#### immediatly invoked Function Expression(IIFE)

Если поместить функцию в скобки, можно ее создать не прикрепляя переменную, имени. И тем самым не сохраняя. И мнгновенно ее вызвать. Одноразовая функция.

    (function () {
      console.log('Again and, Again and, Again');
    })();
    (() => console.log('Again and, Again and, Again'))();

### Closures

The closure is then basically this variable environment attached to the function, exactly as it was at the time and place that the function was created.

Важно не то, где Функция привязана к переменнолй а то, где прописан сам код - function(). Там она и закрепиться в Memory Heap, свалке. И при ее вызове именно оттуда она и возьмет Scope Chain. А не как this Keyword, где зависит место его вызова. !!! Тут важно место обьявления. А где и как привязана к переменной - не суть важна.
// Scope Chain функции зависит от места обьявления самой функции, а не вызова.

    let f;

    const g = function () {
     const a = 23;
     f = function () {
        console.log(`A is ${a}`);
      };
    };

    g();
    f(); // A is 23

Тут Ф получил доступ к переменной А, уже после ее закрытия и вывода с Колл Стака в функции g. Потому что она сохранилась в его Closure, что сохранила цепь ссылок в месте создания - функции g, где доступ к этой переменной А был.

  #
  
  </details> 
  
  <details> <summary>  Array </summary>  

### Базовые операции:

Обьявление:

    const friends = ["Michael", "Steven", "Peter"];
    const y = new Array(1991, 1984, 2008, 2020, 2018);
    
Изменение:`friends[2] = "Jay";`, `years[years.length - 1]`, `years.length`

### Методы - встроенные функции для работы с массивами. Как операторы для массивов
    
 `friends.push("Jay", 1552);` - изменяет массив, добавляя к нему новые значения в конец. `friends.unshift("John");`Добавляет в начало.  Так же сама по себе функция являеться Expression - возвращает длину нового массива: `const newLength = friends.push("Jay", 1552);` - Переменная будет хранить длину обновлённого массива.

`friends.pop();` - Убирает последний елемент массива. Так же и возвращает его. `friends.shift("John");` - убирает первый.

`friends.indexOf("Peter")` - Возвращает номер указанного елемента. Если елемента нет - вернёт -1.

`friends.includes("Peter")` - ES6, более современная версия предыдущего, проверяет на наличие елемент и возвращает буллиан. Проверяет без type coersion, как `===`. Можно круто сочетать с if else.
    

  #
  
  </details> 
  
  <details> <summary>  Objects </summary>  

Обьект имеющий 5 свойств

    const jonasObject = {
      firstname: "Jonas",
      lastname: "Schmedtmann",
      age: 2022 - 1991,
      job: "teacher",
    friends: ["Michael", "Steven", "Peter"],
    };

Два пути получения данных с обьекта: 

`console.log(jonasObject.lastname);` //Первый - через точку. Тут можно указывать ТОЛЬКО имя свойства
`console.log(jonasObject["firstname"]);` // Второй - как с массива, но его плюс: можно вставлять expression's

`    this.bmi = this.mass / this.height ** 2;` - добавление нового свойства в обьект



  #
  
  </details> 
  
  <details> <summary>  For of loop </summary>  

Loops - data structure

    for (let ex = 1; ex <= 4; ex++) {
      console.log(`-----Starting exercise ${ex}-----`);

      for (let rep = 1; rep < 6; rep++) {
        console.log(`Lifting weigths repetition ${rep} 🏋️`);
      }
    }

(`let rep = 1`; `rep < 6`;` rep++`) где первая часть - обьявление переменной, вторая - проверка, и третья - смена после прохождения цикла


For of - такой же как обычный, но подстроенный под работу с массивами данных
                           
    for (const [number, food] of menu.entries()) {
      console.log(`${number + 1}: ${food}`);
    }                  

По сути после конст указываем переменную, куда будет помещен елемент массива. Если массив состоит из массивов - его тут же можно деструктуризировать, как тут `[number, food]`. И все что в блоке кода будет прогнано с каждым елементом массива.
  
  </details> 
